<!doctype html><html lang="en"><head><meta charset="UTF-8"/><title>Tungsten.js</title><link rel="stylesheet" href="css/all.1481661179000.css"/></head><body><div id="layout"><div id="menu"><div class="pure-menu"><a class="pure-menu-heading" href="index.html" id="menu-toggle">Tungsten.js<span class="menu_toggle"></span></a><ul class="pure-menu-list top-menu"><li><a href="index.html" class="pure-menu-link pure-menu-section">Docs</a><ul class="pure-menu-list"><li class="pure-menu-item"><a href="views.html" class="pure-menu-link">Views</a></li><li class="pure-menu-item"><a href="templates.html" class="pure-menu-link">Templates</a></li><li class="pure-menu-item"><a href="models.html" class="pure-menu-link">Models</a></li><li class="pure-menu-item"><a href="components.html" class="pure-menu-link">Components</a></li><li class="pure-menu-item"><a href="debugger.html" class="pure-menu-link">Debugger</a></li><li class="pure-menu-item"><a href="patterns.html" class="pure-menu-link">Patterns</a></li></ul></li><li><a href="tutorials.html" class="pure-menu-link pure-menu-section">Tutorials</a><ul class="pure-menu-list"><li class="pure-menu-item"><a href="tutorials.html#Hello%20World" class="pure-menu-link js-tutorial-select">Hello World</a></li><li class="pure-menu-item"><a href="tutorials.html#Derived%20Props" class="pure-menu-link js-tutorial-select">Derived Props</a></li><li class="pure-menu-item"><a href="tutorials.html#Debugging" class="pure-menu-link js-tutorial-select">Debugging</a></li><li class="pure-menu-item"><a href="tutorials.html#TodoMVC" class="pure-menu-link js-tutorial-select">TodoMVC</a></li><li class="pure-menu-item"><a href="tutorials.html#Views%20&amp;%20Context" class="pure-menu-link js-tutorial-select">Views &amp; Context</a></li><li class="pure-menu-item"><a href="tutorials.html#Events" class="pure-menu-link js-tutorial-select">Events</a></li><li class="pure-menu-item"><a href="tutorials.html#Components" class="pure-menu-link js-tutorial-select">Components</a></li></ul></li><li><a href="sandbox.html" class="pure-menu-link pure-menu-section">Sandbox</a></li><li><a href="examples.html" class="pure-menu-link pure-menu-section">Examples</a><ul class="pure-menu-list"><li class="pure-menu-item"><a href="examples__dbmonster-component.html" class="pure-menu-link js-tutorial-select">DBMonster</a></li><li class="pure-menu-item"><a href="examples__drag-and-drop.html" class="pure-menu-link js-tutorial-select">Drag &amp; Drop</a></li><li class="pure-menu-item"><a href="examples__svg.html" class="pure-menu-link js-tutorial-select">SVG</a></li><li class="pure-menu-item"><a href="examples__web-components.html" class="pure-menu-link js-tutorial-select">Web Components</a></li><li class="pure-menu-item"><a href="examples__todomvc.html" class="pure-menu-link js-tutorial-select">TodoMVC</a></li></ul></li></ul><ul class="pure-menu-list bottom-menu"><li class="pure-menu-item"><a target="_blank" href="https://www.npmjs.com/package/tungstenjs" class="pure-menu-link">npm</a></li><li class="pure-menu-item"><a target="_blank" href="https://github.com/wayfair/tungstenjs" class="pure-menu-link">GitHub</a></li><li class="pure-menu-item"><a target="_blank" href="http://engineering.wayfair.com/" class="pure-menu-link">Wayfair<br>Engineering</a></li></ul></div></div><div class="main" id="appwrapper"><div class="content">
          <h1 id="components">Components</h1>
<p>Components allow standalone Tungsten.js &quot;apps&quot; to be reused and composed to build larger applications.  A component consists of a view, a model with data, and a template.  To create a component, use the Component widget on the adaptor module (currently components are only available for the Backbone adaptor).</p>
<pre><code class="hljs"><span class="hljs-keyword">new</span> ComponentWidget(View, <span class="hljs-keyword">new</span> Model(data), template, options)</code></pre><p>It&#39;s useful to export components from their own index file that handles the view/model/template imports and exports the instance of the <code>ComponentWidget</code>:</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> ComponentWidget = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tungstenjs/adaptors/backbone'</span>).ComponentWidget;

<span class="hljs-keyword">var</span> Model = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./model'</span>);
<span class="hljs-keyword">var</span> View = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./view'</span>);
<span class="hljs-keyword">var</span> template = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./template.mustache'</span>);

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, options</span>) </span>{
  <span class="hljs-keyword">if</span> (data &amp;&amp; data.constructor === ComponentWidget) {
    <span class="hljs-keyword">return</span> data;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ComponentWidget(View, <span class="hljs-keyword">new</span> Model(data), template, options);
};</code></pre><p>Once the component is created, add the component to the model.  One way to do this is via the <code>relations</code> hash:</p>
<pre><code class="hljs">relations: {
  <span class="hljs-attr">my_component</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'path/to/my_component'</span>)
}</code></pre><p>This can then be rendered in the template by referencing the property name of the component and printing it with a triple mustache tag, e.g. <code>{{{ my_component }}}</code>.  If a collection of components are rendered, a section tag and <code>{{{ . }}}</code> can be used:</p>
<pre><code class="hljs"><span class="xml"></span><span class="hljs-template-tag">{{#<span class="hljs-name">my_components</span>}}</span><span class="xml">
  </span><span class="hljs-template-variable">{{{ . }}</span><span class="xml">}
</span><span class="hljs-template-tag">{{/<span class="hljs-name">my_components</span>}}</span><span class="xml"></span></code></pre><h2 id="component-api">Component API</h2>
<p>The APIs of components are important because they are the means by which applications will interact with them.</p>
<h3 id="events">Events</h3>
<p>Events from a component&#39;s model must be explicitly declared in an array on the model&#39;s <code>exposedEvents</code> hash:</p>
<pre><code class="hljs">Model.extend({
  <span class="hljs-attr">exposedEvents</span>: [<span class="hljs-string">'change:completed'</span>]
});</code></pre><p>Setting <code>exposedEvents</code> to <code>true</code> rather than an array will expose all events.</p>
<p>Additional events can also be exposed by passing in an array of event names to <code>exposedEvents</code> on the component options object.</p>
<p>Events on components are namespaced when exposed and they are also encapsulated by the component by default.</p>
<p>To respond to events on a component&#39;s model, a parent or ancestor application/component can listen to the event on the model but will have to scope the listening action to the component. Events on the component&#39;s model must be exposed to its ancestor via the <code>exposedEvents</code> key.</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> ClockModel = BaseModel.extend({
  <span class="hljs-attr">postInitialize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>, <span class="hljs-string">'change:time_component:est_time'</span>, <span class="hljs-keyword">this</span>.updateTime);
    <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>, <span class="hljs-string">'tick:time_component'</span>, <span class="hljs-keyword">this</span>.updateTime);
  },

  <span class="hljs-attr">updateTime</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// update the time</span>
  }
});</code></pre><p>Shown below is how the <code>change</code> event for <code>est_time</code> and a custom <code>tick</code> event on the <code>time_component</code> is exposed.</p>
<pre><code class="hljs"><span class="hljs-keyword">var</span> TimeModel = BaseModel.extend({
  <span class="hljs-attr">exposedEvents</span>: [<span class="hljs-string">'change'</span>, <span class="hljs-string">'change:est_time'</span>, <span class="hljs-string">'tick'</span>],
  ...
});</code></pre><p>In the above snippet,<code>time_component</code> is a child component of the <code>ClockModel</code>. We listen for a <code>change</code> on the model but scope the listening to <code>time_component</code>&#39;s <code>est_time</code> property and call <code>this.updateTime</code> as our callback method.</p>
<p>The table below shows the various ways the above example could have been achieved.</p>
<table>
<thead>
<tr>
<th>Component exposed event</th>
<th style="text-align:center">Parent listeners</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>exposedEvents: [&#39;change&#39;]</code></td>
<td style="text-align:center"><code>this.listenTo(this, &#39;change:my_component&#39;, _.noop)</code></td>
</tr>
<tr>
<td><code>exposedEvents: [&#39;change&#39;]</code></td>
<td style="text-align:center"><code>this.listenTo(this, &#39;change&#39;, _.noop)</code></td>
</tr>
<tr>
<td><code>exposedEvents: [&#39;change:selected&#39;]</code></td>
<td style="text-align:center"><code>this.listenTo(this, &#39;change:my_component:selected&#39;, _.noop)</code></td>
</tr>
<tr>
<td><code>exposedEvents: [&#39;custom_event&#39;]</code></td>
<td style="text-align:center"><code>this.listenTo(this, &#39;custom_event:my_component&#39;, _.noop)</code></td>
</tr>
<tr>
<td><code>exposedEvents: [&#39;custom_event&#39;]</code></td>
<td style="text-align:center"><code>this.listenTo(this, &#39;custom&#39;, _.noop)</code></td>
</tr>
<tr>
<td><code>exposedEvents: [&#39;custom_event&#39;]</code></td>
<td style="text-align:center"><code>this.listenTo(this, &#39;custom:my_component&#39;, _.noop)</code></td>
</tr>
</tbody>
</table>
<p>The preferred way to deal with events on components is to have them bubble as described. You can also listen directly on the component but that poses problems in some situations. Consider a scenario where we listen on the component, we would typically listen for a change on the application model like below</p>
<pre><code class="hljs"><span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'time_component'</span>), <span class="hljs-string">'change:est_time'</span>, <span class="hljs-keyword">this</span>.updateTime);</code></pre><p>This code works fine until we change <code>time_component</code>. For instance, if it gets destroyed and a new one is created then the property <code>est_time</code> on which we are listening for a change event becomes no longer valid. This effectively means our callback will never get called.</p>
<h3 id="methods">Methods</h3>
<p>Custom methods from a component&#39;s model must be explicitly declared in an array on the model&#39;s <code>exposedFunctions</code> hash:</p>
<pre><code class="hljs">Model.extend({
  <span class="hljs-attr">exposedFunctions</span>: [<span class="hljs-string">'myMethod'</span>]
});</code></pre><p>Additional functions can also be exposed by passing in an array of function names to <code>exposedFunctions</code> on the component options object.</p>
<p>The <code>trigger</code>, <code>get</code>, <code>set</code>, and <code>has</code> methods are available by default on each component, and point to their corresponding model functions.</p>

        </div></div></div><script src="js/all.1481661179000.js"></script></body></html>
